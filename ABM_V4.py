"""
///////////////////////////////////////////////////////////////////////////////
//Conference  : Creative Construction Conference (CCC2019)                   //
//Dates       : 29 June - 2 July, 2019                                       //
//Location    : Budapest, Hungary                                            //
//Study Title : Cyber security challenges and vulnerability assessment       //
//                in the construction industry                               //
//Authors     : Bharadwaj R.K.Mantha and Borja Garcia de Soto                //
//Email       : bmantha at nyu dot edu                                       //
//Affiliation : S.M.A.R.T. Construction Research Group,                      //
//              Division of Engineering,                                     //
//				New York University Abu Dhabi.                               //
///////////////////////////////////////////////////////////////////////////////
"""
# general imports
import numpy, gc
import numpy.random
from itertools import combinations

class Project_participants:
    participant_id = 'id'
    participant_type = 'type'

    # project participants (entities as referred in the paper) class with resp attributes
    def __init__(self, participant_id, participant_type):
        self.participant_id = participant_id
        self.participant_type = participant_type

def choose_interaction(Edges):
    # function to choose specific interaction in each iteration
    temp = numpy.random.randint(0, len(Edges))
    #print('temp is:',temp)
    #print('chosen edge is:',Edges[temp])
    return Edges[temp]

def get_int_part_state(list_objects):
    # function to get participants state
    temp = []
    return temp.append([list_objects[0].participant_type,list_objects[1].participant_type])

def interaction_decision():
    # function to decide if the interaction results in a change of vulnerability state
    return numpy.random.choice([True, False], 1, p=[0.25, 0.75])[0]

def after_interaction(list_objects):
	# function that simulates each of the interaction
    if list_objects[0].participant_type == list_objects[1].participant_type:
        #print('yes')
        pass
    elif list_objects[0].participant_type == 'N':
        list_objects[0].participant_type = 'U'

    elif list_objects[0].participant_type == 'U' and list_objects[1].participant_type == 'V':
        list_objects[0].participant_type = 'V'

    elif list_objects[0].participant_type == 'U' and list_objects[1].participant_type == 'N':
        list_objects[1].participant_type = 'U'

    elif list_objects[0].participant_type == 'V' and list_objects[1].participant_type == 'N':
        list_objects[1].participant_type = 'U'

    elif list_objects[0].participant_type == 'V' and list_objects[1].participant_type == 'U':
        list_objects[1].participant_type = 'V'
    return None

def get_all_objects(Project_participants):
	# function to get all the instances of the entity objects created
    for obj in gc.get_objects():
        if isinstance(obj, Project_participants):
            print(obj.participant_id, obj.participant_type)
    return None

def Model(Edges, num_interactions):
	# function that runs the main ABM
    for i in range(num_interactions):
        #print('iteration:',i)
        x = choose_interaction(Edges)
        if interaction_decision():
            #print('yes')
            after_interaction(x)
        else:
            pass


#################### INPUTS ####################################
# N - Normal State; U - Uncertain_State; V-Vulnerable_State

# entity object instance variable, id and system state
OW  = Project_participants('OW','N')

AL  = Project_participants('AL','N')
AT1 = Project_participants('AT1','N')
AT2 = Project_participants('AT2','N')

GCL = Project_participants('GCL','N')
PM  = Project_participants('PM','N')

LL  = Project_participants('LL','N')
SL  = Project_participants('SL','N')

ML  = Project_participants('ML','N')
ME1 = Project_participants('ME1','N')
ME2 = Project_participants('ME2','N')

PL  = Project_participants('PL','N')
PE1 = Project_participants('PE1','N')
PE2 = Project_participants('PE2','N')

EL  = Project_participants('EL','N')
EE1 = Project_participants('EE1','N')
EE2 = Project_participants('EE2','N')

SUP = Project_participants('SUP','N')
CE1 = Project_participants('CE1','N')
CE2 = Project_participants('CE2','N')
SC1 = Project_participants('SC1','N')
SC2 = Project_participants('SC2','N')
SC3 = Project_participants('SC3','N')
SC4 = Project_participants('SC4','N')
SC5 = Project_participants('SC5','V')

############ Network 1 Edges##################

# connections between different entities
Edges = [[OW,AL],[AL,AT1],[AL,AT2],
         [OW,GCL],[GCL,PM],[PM,LL],[PM,SL],
         [PM,PL],[PL,PE1],[PL,PE2],
         [PM,EL],[EL,EE1],[EL,EE2],
         [PM,ML],[ML,ME1],[ML,ME2],
         [PM,SUP],[SUP,CE1],[SUP,CE2],
         [CE1,SC1],[CE1,SC2],
         [CE2,SC3],[CE2,SC4],[CE2,SC5]
         ]

############ Network 2 Edges##################

# connections between different entities
'''
Edges = [[AL,AT1],[AL,AT2],[AT1,AT2],
         [PL,PE1],[PL,PE2],[PE1,PE2],
         [EL,EE1],[EL,EE2],[EE1,EE2],
         [ML,ME1],[ML,ME2],[ME1,ME2],
         [SUP,CE1],[SUP,CE2],
         [CE1,SC1],[CE1,SC2],[SC1,SC2],
         [CE2,SC3],[CE2,SC4],[CE2,SC5],[SC3,SC4],[SC4,SC5],
         [AL, OW], [AL, SUP], [AL, LL], [AL, PM], [AL, ML], [AL, GCL], [AL, SL], [AL, EL], [AL, PL],
         [OW, SUP],[OW, LL], [OW, PM], [OW, ML], [OW, GCL], [OW, SL], [OW, EL], [OW, PL],
         [SUP, LL],[SUP, PM], [SUP,ML], [SUP, GCL], [SUP, SL], [SUP, EL], [SUP, PL],
         [LL, PM], [LL, ML], [LL, GCL], [LL, SL], [LL, EL], [LL, PL],
         [PM, ML], [PM, GCL], [PM, SL], [PM, EL], [PM, PL],
         [ML, GCL],[ML, SL], [ML, EL], [ML, PL],
         [GCL,SL], [GCL, EL], [GCL, PL],
         [SL, EL], [SL, PL],
         [EL, PL]
         ]
'''

# print the length of edges for cross verification
print ('no of edges are:',len(Edges))

# define the number of interactions or iterations
num_interactions = 300

#################### MAIN LOOP ####################################

# print the initial states of the entities
print('states initially are:')
get_all_objects(Project_participants)

# run the ABM
Model(Edges,num_interactions)

# print the final states of the entities
print('states finally are:')
get_all_objects(Project_participants)
