import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib
matplotlib.interactive(True)

#undirected graph

class participant:
    id = 'id'
    type = 'type'
    baseMetric = 'metric'
    baseScore = 'base'
    ebs = 'ebs'
    adj = 'adjNodes'

    def __init__(self,agent_id,agent_type,av,ac,au,c,i,a):
        self.id = agent_id
        self.type = agent_type
        self.adj = []
        self.baseMetric = {"AV":av,"AC":ac,"Au":au,"C":c,"I":i,"A":a}

        AV,AC,Au,C,I,A = getNum(self.baseMetric)
        self.numBM = {"AV":AV,"AC":AC,"Au":Au,"C":C,"I":I,"A":A}
        self.numEBM = {"AV":AV,"AC":AC,"Au":Au,"C":C,"I":I,"A":A}

        self.baseScore = getBaseScore(self.numBM)
        self.ebs = self.baseScore


#function to calculate CVSS base score
def getBaseScore(numMetrics):
    # AV,AC,Au,C,I,A = getNum(baseMetric)
    AV,AC,Au,C,I,A = numMetrics['AV'],numMetrics['AC'],numMetrics['Au'],numMetrics['C'],numMetrics['I'],numMetrics['A']
    Impact = 10.41*(1-(1-C)*(1-I)*(1-A))
    Exploitability = 20*AV*AC*Au
    fImpact = 0 if Impact==0 else 1.176

    BaseScore = (0.6*Impact+0.4*Exploitability-1.5)*fImpact
    BaseScore = round(BaseScore,1)
    return BaseScore


#function to convert metrics value into numeric
def getNum(baseMetric):
    switchAV = {
        'Local': 0.395,
        'Adjacent': 0.646,
        'Network': 1.0,
    };

    switchAC = {
        'High': 0.35,
        'Medium': 0.61,
        'Low': 0.71,
    };

    switchAu = {
        'Multiple': 0.45,
        'Single': 0.56,
        'None': 0.704,
    };

    switchImpact = {
        'None': 0.0,
        'Partial': 0.275,
        'Complete': 0.660,
    };

    numAV = switchAV.get(baseMetric["AV"]);
    numAC = switchAC.get(baseMetric["AC"]);
    numAu = switchAu.get(baseMetric["Au"]);
    numC = switchImpact.get(baseMetric["C"]);
    numI = switchImpact.get(baseMetric["I"]);
    numA = switchImpact.get(baseMetric["A"]);

    return numAV,numAC,numAu,numC,numI,numA;






######## MAIN #########

#define participant nodes
NWH = participant('NWH','owner','Local','High','Multiple','Complete','Partial','Partial')
FBL = participant('FBL','manager','Network','Medium','None','Partial','Partial','None')
CJO = participant('CJO','contractor','Adjacent','Low','Single','None','Partial','None')
HE = participant('HE','contractor','Local','Medium','Single','Partial','None','Partial')
BSL = participant('BSL','manager','Local','Medium','Single','Partial','Partial','Partial')
TSS = participant('TSS','equipment','Local','Low','Single','Partial','None','Partial')
JHA = participant('JHA','laborer','Local','Low','None','Partial','Partial','Partial')
SGB = participant('SGB','laborer','Local','Medium','None','Partial','Partial','Partial')
CL = participant('CL','equipment','Local','Medium','Single','Partial','None','Partial')
STATS = participant('STATS','contractor','Network','Medium','Single','None','Partial','Partial')
HLE = participant('HLE','contractor','Network','Medium','Single','None','Partial','None')
MPC = participant('MPC','laborer','Local','Low','None','Partial','Partial','None')
TWE = participant('TWE','laborer','Local','Medium','None','None','None','Partial')
HAM = participant('HAM','equipment','Local','Low','Single','Partial','None','Partial')
CBX = participant('CBX','equipment','Local','Low','Single','Partial','None','Partial')
XRX = participant('XRX','equipment','Local','Low','Single','Partial','None','Partial')
HI = participant('HI','equipment','Local','Low','Single','Partial','None','Partial')
UMG = participant('UMG','equipment','Local','Low','Single','Partial','None','Partial')

#create graph and add nodes and edges
G = nx.Graph()
G.add_nodes_from([NWH,FBL,CJO,HE,BSL,TSS,JHA,SGB,CL,STATS,HLE,MPC,TWE,HAM,CBX,XRX,HI,UMG])
G.add_edges_from([
    (NWH,CJO,{'weight': 0.5}),
    (NWH,HE,{'weight': 0.5}),
    (NWH,BSL,{'weight': 0.5}),
    (NWH,TSS,{'weight': 0.5}),
    (NWH,JHA,{'weight': 0.5}),
    (NWH,SGB,{'weight': 0.5}),
    (NWH,CL,{'weight': 0.5}),
    (NWH,STATS,{'weight': 0.5}),
    (NWH,FBL,{'weight': 0.5}),
    (HE,HLE,{'weight': 0.5}),
    (HLE,HAM,{'weight': 0.5}),
    (HLE,HI,{'weight': 0.5}),
    (HLE,CBX,{'weight': 0.5}),
    (HLE,MPC,{'weight': 0.5}),
    (HI,UMG,{'weight': 0.5}),
    (CBX,XRX,{'weight': 0.5}),
    (MPC,TWE,{'weight': 0.5})
])



#function to update effective base metrics along the path (attack graph)
def effective_base_metrics(current,ancestor):
    for metric in current.baseMetric:
        #update effective base metrics if ancestoral nodes have higher metrics value
        #if previous nodes have been already exploited,
        #future nodes in the same network are also vulnerable
        #that is, there is no meaning of keeping lower metrics value once exploited
        if current.numEBM[metric] < ancestor.numEBM[metric]:
            current.numEBM[metric] = ancestor.numEBM[metric]
        # else:
        #     current.numEBM[metric] = current.numBM[metric]

    #update effective base metrics
    current.ebs = getBaseScore(current.numEBM)

def most_critical_path_to_node(target):
    highest = 0 #conditional probability of the most critical path
    critical_path = []
    for node in [rawnode for rawnode in G.nodes if rawnode != target]: #exclude target node
        for path in nx.all_simple_paths(G,source=node,target=target): #find all paths to target node
            ancestor = path[0]
            path_security = ancestor.ebs/10 #probability of exploiting the node is defined ebs/10

            #print nodes in the path
            print("agent",path[0].id)
            print(path[0].numBM)
            print(path[0].numEBM)
            for path_step in path[1:]:
                print("agent",path_step.id)
                print("BM ", path_step.numBM)
                # print(path_step.numEBM)

                #update effective base metrics along the path and calculate conditional probability
                effective_base_metrics(path_step,ancestor)
                print("BM ", path_step.numBM)
                # print("EBM ", path_step.numEBM)
                path_security *= path_step.ebs/10
                ancestor = path_step

                # print(path_step.numEBM)

            print("path_security:",path_security)

            #check if current path has the highest probability and store the path
            highest = max(highest,path_security)
            if highest == path_security: #store path of highest probability in critical_path
                critical_path = path

            #reset effective base score and effective base metrics of all nodes along the path
            for step in path:
                if step.numEBM != step.numBM:
                    # print("Reset ",step.id)
                    # print(step.numEBM)
                    step.ebs = step.baseScore
                    step.numEBM = step.numBM
                    # print(step.numEBM)

            print("")

    #return result
    print("final highest:",highest)
    print("critical_path:")
    for critical_step in critical_path:
        print(critical_step.id)


most_critical_path_to_node(TWE)
