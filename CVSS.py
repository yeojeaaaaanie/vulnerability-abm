import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib
matplotlib.interactive(True)
"""
#undirected graph
class network:
    size = 'size'
    participants = 'participants'

    def __init__(self):
        self.participants = []
        self.size = 0

    def addNode(self, newNode):
        self.participants.append(newNode)
        self.size += 1

    def addEdge(self,u,v):
        indexu = self.participants.index(u)
        indexv = self.participants.index(v)
        try:
            self.participants[indexu].adj.append(v)
            self.participants[indexv].adj.append(u)
        except:
            print("error adding edge")

    #depth-first traversal method
    def vIntroduced(self,root,**kwargs):
        visited = []
        queue = []

        visited.append(root)
        queue.append(root)

        while queue:
            queue[0].influenced(**kwargs)
            next = queue.pop(0)
            # print("next: ",next)

            for children in next.adj:
                if children not in visited:
                    # print(children," not visited")
                    visited.append(children)
                    queue.append(children)

"""
class participant:
    id = 'id'
    type = 'type'
    baseMetric = 'metric'
    baseScore = 'base'
    ebs = 'ebs'
    adj = 'adjNodes'

    def __init__(self,agent_id,agent_type,av,ac,au,c,i,a):
        self.id = agent_id
        self.type = agent_type
        self.adj = []
        self.baseMetric = {"AV":av,"AC":ac,"Au":au,"C":c,"I":i,"A":a}

        AV,AC,Au,C,I,A = getNum(self.baseMetric)
        self.numBM = {"AV":AV,"AC":AC,"Au":Au,"C":C,"I":I,"A":A}
        self.numEBM = {"AV":AV,"AC":AC,"Au":Au,"C":C,"I":I,"A":A}

        self.baseScore = getBaseScore(self.numBM)
        self.ebs = self.baseScore

    def influenced(self,**kwargs):
        for metricType,newValue in kwargs.items():
            tempMetric = self.baseMetric
            tempMetric[metricType] = newValue

        if (getBaseScore(tempMetric) > self.baseScore):
            self.baseMetric[metricType] = newValue
            self.ebs = getBaseScore(self.baseMetric)
        else:
            self.ebs = self.baseScore

def getBaseScore(numMetrics):
    # AV,AC,Au,C,I,A = getNum(baseMetric)
    AV,AC,Au,C,I,A = numMetrics['AV'],numMetrics['AC'],numMetrics['Au'],numMetrics['C'],numMetrics['I'],numMetrics['A']
    Impact = 10.41*(1-(1-C)*(1-I)*(1-A))
    Exploitability = 20*AV*AC*Au
    fImpact = 0 if Impact==0 else 1.176

    BaseScore = (0.6*Impact+0.4*Exploitability-1.5)*fImpact
    BaseScore = round(BaseScore,1)
    return BaseScore

def getNum(baseMetric):
    switchAV = {
        'Local': 0.395,
        'Adjacent': 0.646,
        'Network': 1.0,
    };

    switchAC = {
        'High': 0.35,
        'Medium': 0.61,
        'Low': 0.71,
    };

    switchAu = {
        'Multiple': 0.45,
        'Single': 0.56,
        'None': 0.704,
    };

    switchImpact = {
        'None': 0.0,
        'Partial': 0.275,
        'Complete': 0.660,
    };

    numAV = switchAV.get(baseMetric["AV"]);
    numAC = switchAC.get(baseMetric["AC"]);
    numAu = switchAu.get(baseMetric["Au"]);
    numC = switchImpact.get(baseMetric["C"]);
    numI = switchImpact.get(baseMetric["I"]);
    numA = switchImpact.get(baseMetric["A"]);

    return numAV,numAC,numAu,numC,numI,numA;






######## MAIN #########
#add weights to each path

#aggregate total BaseScore

#find the most critical path given a addNode





agent1 = participant('1','owner','Local','High','Multiple','Complete','Partial','Partial')
agent2 = participant('2','manager','Network','Medium','None','Partial','Partial','None')
agent3 = participant('3','contractor','Adjacent','Low','Single','None','Partial','None')
agent4 = participant('4','contractor','Local','Medium','Single','Partial','None','Partial')
agent5 = participant('5','manager','Local','Medium','Single','Partial','Partial','Partial')
agent6 = participant('6','equipment','Local','Low','Single','Partial','None','Partial')
agent7 = participant('7','laborer','Local','Low','None','Partial','Partial','Partial')
agent8 = participant('8','laborer','Local','Medium','None','Partial','Partial','Partial')
agent9 = participant('9','equipment','Local','Medium','Single','Partial','None','Partial')
agent10 = participant('10','contractor','Network','Medium','Single','None','Partial','Partial')
agent11 = participant('11','contractor','Network','Medium','Single','None','Partial','None')
agent12 = participant('12','laborer','Local','Low','None','Partial','Partial','None')
agent13 = participant('13','laborer','Local','Medium','None','None','None','Partial')
agent14 = participant('14','equipment','Local','Low','Single','Partial','None','Partial')

# testn = network()
# testn.addNode(agent1)
# testn.addNode(agent2)
# testn.addNode(agent3)
# testn.addNode(agent4)
# testn.addEdge(agent1,agent2)
# testn.addEdge(agent2,agent3)
# testn.addEdge(agent2,agent4)
#
# kwargs = {"AV":"Network","AC":"Low"}
# testn.vIntroduced(agent1,**kwargs)
# print("agent | Base|EBS")
# print("agent1| ", agent1.baseScore, agent1.ebs)
# print("agent2| ", agent2.baseScore,agent2.ebs)
# print("agent3| ", agent3.baseScore,agent3.ebs)
# print("agent4| ", agent4.baseScore,agent4.ebs)

#using networkx
G = nx.Graph()
G.add_nodes_from([agent1,agent2,agent3,agent4])
G.add_edges_from([
    (agent1,agent2,{'weight': 0.5}),
    (agent2,agent3,{'weight': 0.75}),
    (agent2,agent4,{'weight': 0.5}),
    (agent3,agent6,{'weight': 0.25}),
    (agent4,agent7,{'weight': 0.5}),
    (agent4,agent8,{'weight': 0.5}),
    (agent4,agent9,{'weight': 0.5}),
    (agent1,agent5,{'weight': 0.5}),
    (agent5,agent10,{'weight': 0.25}),
    (agent5,agent11,{'weight': 0.75}),
    (agent11,agent4,{'weight': 0.5}),
    (agent11,agent12,{'weight': 0.75}),
    (agent11,agent13,{'weight': 0.5}),
    (agent11,agent14,{'weight': 0.5}),
    (agent12,agent9,{'weight': 0.25})
])

def vIntroduced(root,**kwargs):
    visited = []
    queue = []

    visited.append(root)
    queue.append(root)

    while queue:
        queue[0].influenced(**kwargs)
        next = queue.pop(0)

        for children in G.adj[next]:
            if children not in visited:
                visited.append(children)
                queue.append(children)

# kwargs = {"AV":"Network","AC":"Low"}
# vIntroduced(agent1,**kwargs)
# print("agent | Base|EBS")
# print("agent1| ", agent1.baseScore, agent1.ebs)
# print("agent2| ", agent2.baseScore,agent2.ebs)
# print("agent3| ", agent3.baseScore,agent3.ebs)
# print("agent4| ", agent4.baseScore,agent4.ebs)

labels = {}
for node in G.nodes:
    labels[node] = node.id
pos = nx.spring_layout(G)
weights = nx.get_edge_attributes(G,'weight')

# plt.figure()
# nx.draw(G, pos,labels=labels, with_labels=True, font_weight='bold')
# nx.draw_networkx_edge_labels(G, pos, edge_labels=weights)
# plt.savefig('graph.png')










# print("bs: ",getBaseScore({"AV":'Local',"AC":'Medium',"Au":'Single',"C":'Complete',"I":'Complete',"A":'Partial'}))
# print("ebs:",getBaseScore({"AV":'Network',"AC":'Medium',"Au":'None',"C":'Complete',"I":'Complete',"A":'Partial'}))


# def path_security(path):

path = ['6', '3', '2']
temp = 'agent' + path[0]
# print(temp)

# for step in path: #assign
#     kwargs = {"AV":"network"}
#     step = 'agent' + step
#     print(step)
#     agent6.influenced(**kwargs)
    # step.influenced(**kwargs)
    # print(step.ebs)

print(agent6.baseMetric['AV'])
mapping = {object:object.id for object in G.nodes}
H = nx.relabel_nodes(G,mapping)

temp = 'agent'+path[0]
# print(type(temp))
# print(type(agent6))
# temp.influenced(**{"AV":"Network"})
# for step in path:

# 1. convert string to variable name
# 2. get conditional probability of each participant from cvss score/10
#     - ebs from influenced data? or somethign else?
# 3. compute conditional probability of target and return it

# print(agent6.baseScore)
# print(agent3.baseScore)
# print(agent2.baseScore)




def effective_base_metrics(current,ancestor):
    for metric in current.baseMetric:
        if current.numEBM[metric] < ancestor.numEBM[metric]:
            current.numEBM[metric] = ancestor.numEBM[metric]
        else:
            current.numEBM[metric] = current.numBM[metric]

    current.ebs = getBaseScore(current.numEBM)
# effective_base_metrics(agent2,agent3)


def most_critical_path_to_node(target):
    # mapping = {object:object.id for object in G.nodes}
    # H = nx.relabel_nodes(G,mapping)
    #
    # # for node in [rawnode for rawnode in H.nodes if rawnode != target.id]:
    # #     for path in nx.all_simple_paths(H,source=node,target=target.id):
    # #         # ancestor = path[0]
    # #         # for path_step in path[1:]:
    # #         #     print(path_step,ancestor)
    # #         #     # effective_base_metrics(path_step,ancestor)
    # #         #     ancestor = path_step

    highest = 0
    critical_path = []
    for node in [rawnode for rawnode in G.nodes if rawnode != target]:
        for path in nx.all_simple_paths(G,source=node,target=target):
            ancestor = path[0]
            path_security = ancestor.ebs/10
            print("agent",path[0].id)
            for path_step in path[1:]:
                print("agent",path_step.id)
                effective_base_metrics(path_step,ancestor)
                path_security *= path_step.ebs/10
                ancestor = path_step
            print("path_security:",path_security)
            highest = max(highest,path_security)
            if highest == path_security:
                critical_path = path

            for path_step in path[1:]:
                path_step.ebs = path_step.baseScore
                
    print("final highest:",highest)
    print("critical_path:")
    for critical_step in critical_path:
        print(critical_step.id)


most_critical_path_to_node(agent2)
